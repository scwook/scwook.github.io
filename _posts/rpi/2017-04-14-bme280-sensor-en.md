---
layout: post
title: "BME280 Sensor Test"
show: true
language:
  - en
  - kr
categories: RaspberryPi
---
BME280 is an integrated environmental sensor which can measure temperature, humidity and pressure. Basic specifications of the sensor are as follow and More detailed information can be founded in [BME280](https://www.bosch-sensortec.com/bst/products/all_products/bme280).

* Humidity Accuracy [%RH]: ±2
* Temperature [℃]: ±0.5
* Supply Voltage [V]: 1.71 to 3.6
* Interface: I2C and SPI

In order to test, [WiringPi]({{site.url}}/raspberrypi/2016/05/20/wiringPi-installation-en.html) and [I2C]({{site.url}}/raspberrypi/2017/04/13/i2c-configuration-en.html) are must be configured.

### Component

* Raspberry Pi 2 Model B
* [BME280](https://www.embeddedadventures.com/bme280_weather_multi_sensor_mod-1022.html)

![BME280 Test Circuit]({{site.url}}/images/rpi_bme280_test.png)

### Source Code

All this source code is based on following Pythone code and I modified the code for wiringPi library.

[https://github.com/SWITCHSCIENCE/BME280/blob/master/Python27/bme280_sample.py](https://github.com/SWITCHSCIENCE/BME280/blob/master/Python27/bme280_sample.py)

filename: bme280.c

{% highlight c linenos %}
#include <stdio.h>
#include <wiringPi.h>
#include <wiringPiI2C.h>

#define TRUE 1
#define FALSE 0

#define DEV_ADDR 0x76

int digT[3];
int digP[9];
int digH[6];
double t_fine;

void compensate_T(int adc_T);
void compensate_P(int adc_P);
void compensate_H(int adc_H);

void writeReg(int fd, int reg_address, int data)
{
  wiringPiI2CWriteReg8(fd, reg_address, data);
}

void reset(int fd)
{
  writeReg(fd, 0xE0, 0xB6);
}

void getCalbParm(int fd)
{
  int calib[32];
  int reg = 0x88;

  int i;
  for(i = 0; i < 24; i++)
    calib[i] = wiringPiI2CReadReg8(fd, reg+i);

  calib[24] = wiringPiI2CReadReg8(fd, 0xA1);

  for(i = 0; i < 7; i++)
    calib[i+25] = wiringPiI2CReadReg8(fd, 0xE1+i);

  digT[0] = calib[1] << 8 | calib[0];
  digT[1] = calib[3] << 8 | calib[2];
  digT[2] = calib[5] << 8 | calib[4];
  digP[0] = calib[7] << 8 | calib[6];
  digP[1] = calib[9] << 8 | calib[8];
  digP[2] = calib[11] << 8 | calib[10];
  digP[3] = calib[13] << 8 | calib[12];
  digP[4] = calib[15] << 8 | calib[14];
  digP[5] = calib[17] << 8 | calib[16];
  digP[6] = calib[19] << 8 | calib[18];
  digP[7] = calib[21] << 8 | calib[20];
  digP[8] = calib[23] << 8 | calib[22];
  digH[0] = calib[24];
  digH[1] = calib[26] << 8 | calib[25];
  digH[2] = calib[27];
  digH[3] = calib[28] << 4 | (0x0F & calib[29]);
  digH[4] = calib[30] << 4 | ((calib[29] >> 4) & 0x0F);
  digH[5] = calib[31];

  for(i = 1; i < 2; i++)
    if(digT[i] & 0x8000) digT[i] = (-digT[i] ^ 0xFFFF) + 1;

  for(i = 1; i < 8; i++)
    if(digP[i] & 0x8000) digP[i] = (-digP[i] ^ 0xFFFF) + 1;

  for(i = 0; i < 6; i++)
    if(digH[i] & 0x8000) digH[i] = (-digH[i] ^ 0xFFFF) + 1;
}

void readData(int fd)
{
  int data[8];
  int reg = 0xF7;

  int i;
  for(i = 0; i < 8; i++)
    data[i] = wiringPiI2CReadReg8(fd, reg+i);

  int pres_raw = data[0] << 12 | data[1] << 4 | data[2] >> 4;
  int temp_raw = data[3] << 12 | data[4] << 4 | data[5] >> 4;
  int hum_raw = data[6] << 8 | data[7];

  compensate_T(temp_raw);
  compensate_P(pres_raw);
  compensate_H(hum_raw);
}

void compensate_P(int adc_P)
{
  double pressure = 0.0;
  double var1, var2;

  var1 = (t_fine / 2.0) - 64000.0;
  var2 = (((var1 / 4.0) * (var1 / 4.0)) / 2048) * digP[5];
  var2 = var2 + ((var1 * digP[4]) * 2.0);
  var2 = (var2 / 4.0) + (digP[3] * 65536.0);
  var1 = (((digP[2] * (((var1 / 4.0) * (var1 / 4.0)) / 8192)) / 8) + ((digP[1] * var1) / 2.0)) / 262144;
  var1 = (32768 + var1) * digP[0] / 32768;

  if(var1 == 0) return;

  pressure = ((1048576 - adc_P) - (var2 / 4096)) * 3125;

  if(pressure < 0x80000000) pressure = (pressure * 2.0) / var1;
  else
    pressure = (pressure / var1) * 2.0;

  var1 = (digP[8] * (((pressure / 8.0) * (pressure / 8.0)) / 8192.0)) / 4096;
  var2 = ((pressure / 4.0) * digP[7]) / 8192.0;
  pressure = pressure + ((var1 + var2 + digP[6]) / 16.0);

  printf("pres : %.2fhPa\n", pressure/100);

}

void compensate_T(int adc_T)
{
  double var1, var2, T;
  var1 = (adc_T / 16384.0 - digT[0] / 1024.0) * digT[1];
  var2 = (adc_T / 131072.0 - digT[0] / 8192.0) * (adc_T / 131072.0 - digT[0] / 8192.0) * digT[2];
  t_fine = var1 + var2;
  T = t_fine / 5120.0;

  printf("temp : %.2f℃\n", T);
}

void compensate_H(int adc_H)
{
  double var_h;

  var_h = t_fine - 76800.0;

  if(var_h != 0)
    var_h = (adc_H - (digH[3] * 64.0 + digH[4]/16384.0 * var_h)) * (digH[1] / 65536.0 * (1.0 + digH[5] / 67108864.0 * var_h * (1.0 + digH[2] / 67108864.0 * var_h)));
  else return;

  var_h = var_h * (1.0 - digH[0] * var_h / 524288.0);

  if(var_h > 100.0) var_h = 100.0;
  else if(var_h < 0.0) var_h = 0.0;

  printf("hum : %.2f％\n", var_h);

}

void setup(int fd)
{
  unsigned char osrs_t = 1;
  unsigned char osrs_p = 1;                      //Pressure oversampling x 1
  unsigned char osrs_h = 1;                      //Humidity oversampling x 1
  unsigned char mode   = 3;                      //Normal mode
  unsigned char t_sb   = 5;                      //Tstandby 1000ms
  unsigned char filter = 0;                      //Filter off
  unsigned char spi3w_en = 0;                    //3-wire SPI Disable

  unsigned char ctrl_meas_reg = (osrs_t << 5) | (osrs_p << 2) | mode;
  unsigned char config_reg    = (t_sb << 5) | (filter << 2) | spi3w_en;
  unsigned char ctrl_hum_reg  = osrs_h;

  writeReg(fd, 0xF2,ctrl_hum_reg);
  writeReg(fd, 0xF4,ctrl_meas_reg);
  writeReg(fd, 0xF5,config_reg);
}

int main(void)
{
  if(wiringPiSetup() == -1)
  {
    printf("Unable to start wiringPi\n");
    return 1;
  }

  int fd = wiringPiI2CSetup(DEV_ADDR);

  if(fd == -1)
  {
    printf("Can't open i2c device\n");
    return 1;
  }

  int i;

  for(i=0; i<3; i++) digT[i] = 0;
  for(i=0; i<9; i++) digP[i] = 0;
  for(i=0; i<6; i++) digH[i] = 0;

  t_fine = 0.0;

  reset(fd);
  setup(fd);
  getCalbParm(fd);
  readData(fd);

  return 0;
}
{% endhighlight %}

### Test

Compile and run the program.

{% highlight console %}
pi@raspberrypi ~$ gcc -o bme280 bme280.c -lwiringPi
pi@raspberrypi ~$ sudo ./bme280
{% endhighlight %}
